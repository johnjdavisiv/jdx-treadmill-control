function run_experiment(sub_code, t, trial_speeds_m_s, trial_start, trial_end, walk_ind)
%Run treadmill protocol given speeds in m/s and trial start/end times


%Treadmill acceleration - DO NOT CHANGE unless you know what you are doing!
accel_m_s2 = 0.25; %m/s^2


%Inputs
%sub_code - subject code as string, e.g. 'S001'

%t - TCP/IP connection from open_treadmill_comm()

% trial_speeds_m_s - nx1 vector of speeds for each trial in meters per second
%                   generated by get_trial_speeds_from_pace()
%
% trial_start - nx1 vector of start times, in minutes, for each trial (as total elapsed time)

% trial_end - nx1 vector of end times, in minutes, for each trial (as total elapsed time)

% walk_ind - nx1 vector of 0/1 values indicating if a trial is walking (or standing)
%             can use to determine if both or just one belt should be on, if desired

%Outputs

%nothing explicitly but logs treadmill speeds in a csv

%Log experiment start time
exp_start_time = datetime('now', 'TimeZone', 'local');

%Filename for treadmill speed log csv - may need aboslute path! For robustness
try
    log_fname = create_treadmill_log(sub_code, exp_start_time);
catch
    error('Problem with creating treadmill log - try changing directories?');
end

%Start timer
t_tic = tic;

%While loop params
halt_exp = 0;
last_loop_trial = 1;

%First progress bar outside?
fprintf(1,'\n');
fprintf(1, '------------- Starting instructions -------------\n');
fprintf(1,'Subject should be on treadmill and audio should be playing\n');
fprintf(1,'\n');
fprintf(1,'Instructions duration: %.1f min\n', trial_end(1));
fprintf(1,'\n');
progress_bar_first_line();

while ~halt_exp    
    %Toc always returns float seconds
    % --------------------------------------------------------
    % --- IMPORTANT --- this is where you switch from test mode (in seconds) to real trials!
    % Divide the toc output by 60 to get minutes!
    elapsed_time = toc(t_tic)/60; 
    % --------------------------------------------------------
    
    timestamp = posixtime(datetime('now', 'TimeZone', 'local'));
        
    %What trial are we on?
    current_trial = find(trial_start < elapsed_time, 1,'last');
    current_speed_m_s = trial_speeds_m_s(current_trial);
    current_walk_ind = walk_ind(current_trial);

    %Elapsed time in this trial is difference between elapsed time and when trial started
    trial_elapsed_time = elapsed_time - trial_start(current_trial);
    
    %Trial progress (as a float from 0 to 1)
    trial_progress = trial_elapsed_time/(trial_end(current_trial) - trial_start(current_trial));
    progress_bar(trial_progress*100);
    
    %For speed display
    current_speed_mph = current_speed_m_s*2.237;
    
    if current_speed_mph > 0
        this_min_mi_dec = 1/(current_speed_mph/60);   
        pace_min = floor(this_min_mi_dec);
        pace_sec = floor(60*(this_min_mi_dec - pace_min));
    else
        %Really just for walk
        pace_min = 0;
        pace_sec = 0;
    end
    
    if current_trial > last_loop_trial
        progress_bar(100);
        last_loop_trial = current_trial; 
        
        fprintf(1,'\n');
        fprintf(1, '------------- Starting trial %i -------------\n', current_trial);
        fprintf(1,'\n');
        fprintf(1,'Trial duration: %.1f min\n', trial_end(current_trial) - trial_start(current_trial));
        fprintf(1, 'Updating speed to %.2f m/s  |  %.1f mph  |  %i:%02i/mi\n', ...
            current_speed_m_s, current_speed_mph, pace_min, pace_sec);
        %Next progress bar
        progress_bar_first_line();
    end
    
    %Also need to know if walking or running, because belts!
    [speed_commands, treadmill_packet] = set_treadmill_speed(t, current_speed_m_s, accel_m_s2, current_walk_ind);
    %Walk ind sets whether or not both belts move
    
    try
        update_treadmill_log(log_fname, timestamp, elapsed_time, speed_commands, treadmill_packet);
    catch
        warning('Could not update treadmill log! Is path OK?');
    end
        
    
    if elapsed_time > trial_end(end)
        halt_exp = 1;
        fprintf('');
    end
    
    %Pause/delay until next loop
    pause(0.5);
    %At least on local tcpip echo server, you get <0.01sec updates if no pause
    
end

end

